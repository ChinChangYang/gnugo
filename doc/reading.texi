@cindex Reading code
@cindex Reading process
@cindex Trying hypothetical moves
@cindex Usage of the stack in reading
@cindex reading DEPTH
@cindex Depth of reading
@cindex reading.c
@cindex reading.h

The process of visualizing potential moves done by you and your
opponent to learn the result of different moves is called
"reading". GNU Go does three distinct types of reading: @dfn{tactical
reading} which typically is concerned with the life and death of
individual strings, @dfn{Owl reading} which is concerned
with the life and death of dragons, and @dfn{life reading}
which attempts evaluate eye spaces. In this Chapter, we document
the tactical reading code, which is in @file{engine/reading.c}.
For a summary of the reading functions see @xref{Reading Functions}.

@menu
* Reading Basics::               Reading Basics
* Hashing::                      Hashing of positions
* Persistent Cache::             Persistent Reading Cache
* Ko::                           Ko handling
* A Ko Example::                 A Ko Example
* Another Ko Example::           Another Ko Example
* Alternate Komaster Schemes::   Alternate Komaster Schemes
* Superstrings::                 Superstrings
* Reading Functions::            Utilities from @file{engine/reading.c}
* Debugging::                    Debugging the reading code
@end menu

@node Reading Basics, Hashing, Tactical Reading, Tactical Reading
@comment  node-name,  next,  previous,  up
@section Reading Basics

In GNU Go, tactical reading is done by the functions in
@file{engine/reading.c}. Each of these functions has a separate goal to fill,
and they call each other recursively to carry out the reading process.

The reading code makes use of a stack onto which board positions can
be pushed. The parameter @code{stackp} is zero if GNU Go is
examining the true board position; if it is higher than zero, then
GNU Go is examining a hypothetical position obtained by playing
several moves.

The most important public reading functions are @code{attack} and
@code{find_defense}. These are wrappers for functions @code{do_attack} and
@code{do_find_defense} which are declared statically in @file{reading.c}. The
functions @code{do_attack} and @code{do_find_defense} call each other
recursively.

@cindex return codes
@cindex reading return codes

The return codes of the reading (and owl) functions and owl can
be 0, 1, 2 or 3. Each reading function determines whether a
particular player (assumed to have the move) can solve a
specific problem, typically attacking or defending a string.

The nonzero return codes are called these names in the source:

@example
   #define WIN  3
   #define KO_A 2
   #define KO_B 1
@end example

A return code of WIN means success, 0 failure, while KO_A and
KO_B are success conditioned on ko. A function returns KO_A
if the position results in ko and that the player to move
will get the first ko capture (so the opponent has to make the
first ko threat). A return code of KO_B means that the player
to move will have to make the first ko threat.

Many of the reading functions make use of @dfn{null pointers}.
For example, a call to @code{attack(str, &apos)} will return WIN
if the string at @code{str} can be captured. The point of attack
(in case it is vulnerable) is returned in @code{apos}. However
many times we do not care about the point of attack. In this
case, we can substitute a null pointer: @code{attack(str,
NULL)}.

Depth of reading is controlled by the parameters @code{depth}
and @code{branch_depth}. The @code{depth} has a default value
@code{DEPTH} (in @file{liberty.h}), which is set to 14 in the
distribution, but it may also be set at the command line using
the @option{-D} or @option{--depth} option.  If @code{depth} is
increased, GNU Go will be stronger and slower. GNU Go will read
moves past depth, but in doing so it makes simplifying
assumptions that can cause it to miss moves.

Specifically, when @code{stackp > depth}, GNU Go assumes that as
soon as the string can get 3 liberties it is alive. This
assumption is sufficient for reading ladders.

The @code{branch_depth} is typically set a little below @code{depth}.
Between @code{branch_depth} and @code{depth}, attacks on strings with
3 liberties are considered, but branching is inhibited, so fewer
variations are considered.

@findex small_semeai
Currently the reading code does not try to defend a string by
attacking a boundary string with more than two liberties. Because
of this restriction, it can make oversights. A symptom of this is
two adjacent strings, each having three or four liberties, each
classified as @code{DEAD}. To resolve such situations, a function
@code{small_semeai()} (in @file{engine/semeai.c}) looks for such
pairs of strings and corrects their classification.

The @code{backfill_depth} is a similar variable with a default 10. Below
this depth, GNU Go will try "backfilling" to capture stones.
For example in this situation:

@example
@group

.OOOOOO.    on the edge of the board, O can capture X but
OOXXXXXO    in order to do so he has to first play at a in
.aObX.XO    preparation for making the atari at b. This is
--------    called backfilling.

@end group
@end example

Backfilling is only tried with @code{stackp <= backfill_depth}. The
parameter @code{backfill_depth} may be set using the @option{-B}
option.

The @code{fourlib_depth} is a parameter with a default of only 5.
Below this depth, GNU Go will try to attack strings with
four liberties. The @code{fourlib_depth} may be set using the
@option{-F} option.

The parameter @code{ko_depth} is a similar cutoff. If
@code{stackp<ko_depth}, the reading code will make experiments
involving taking a ko even if it is not legal to do so (i.e., it
is hypothesized that a remote ko threat is made and answered
before continuation).  This parameter may be set using the
@option{-K} option.

@cindex reading.c

A partial list of the functions in @file{reading.c} (@pxref{Reading
Functions} for a fuller list).

@itemize @bullet
@item @code{int attack(int str, int *move)}
@findex attack
@quotation
This basic function determines if the string at @code{str} can
be attacked, and if so, @code{*move} returns the attacking move,
unless @code{*movei} is a null pointer. (Use null pointers if
you are interested in the result of the attack but not the
attacking move itself.) Returns 1 if the attack succeeds,
otherwise 0. Returns @code{KO_A} or @code{KO_B} if the result depends on ko:
returns @code{KO_A} if the attack succeeds provided attacker is willing
to ignore any ko threat. Returns @code{KO_B} if attack succeeds
provided attacker has a ko threat which must be answered.  
@end quotation
@findex find_defense
@item @code{find_defense(int str, int *move)}
@quotation 
Attempts to find a move that will save the string at @code{str}. It
returns true if such a move is found, with @code{*move} the location
of the saving move (unless @code{*move} are null pointers). It is not
checked that tenuki defends, so this may give an erroneous answer if
@code{!attack(str)}.  Returns @code{KO_A} or @code{KO_B} if the
result depends on ko. Returns @code{KO_A} if the string can be
defended provided @code{color} is willing to ignore any ko
threat. Returns @code{KO_B} if @code{color} has a ko threat which must be
answered.  
@end quotation
@findex safe_move
@item @code{safe_move(int str, int color)} :
@quotation
The function @code{safe_move(str, color)} checks whether a move at
@code{str} is illegal or can immediately be captured. If @code{stackp==0}
the result is cached. If the move only can be captured by a ko, it's
considered safe. This may or may not be a good convention.
@end quotation
@end itemize

@node Hashing, Hash Calculation, Reading Basics, Tactical Reading
@comment  node-name,  next,  previous,  up
@section Hashing of Positions

@cindex Hashing of positions
@cindex Reading optimisation
@cindex speedup of reading process
@cindex Zobrist hashing algorithm
@cindex Transposition table

To speed up the reading process, we note that a position can be
reached in several different ways.  In fact, it is a very common
occurrence that a previously checked position is rechecked, often
within the same search but from a different branch in the recursion
tree. 

This wastes a lot of computing resources, so in a number of places, we
store away the current position, the function we are in, and which worm
is under attack or to be defended.  When the search for this position
is finished, we also store away the result of the search and which
move made the attack or defense succeed.

All this data is stored in a hash table, sometimes also called a
transposition table, where Go positions are the key and results of the
reading for certain functions and groups are the data. You can increase
the size of the Hash table using the @option{-M} or @option{--memory}
option @pxref{Invoking GNU Go}.

The hash table is created once and for all at the beginning of
the game by the function @code{hashtable_new()}. Although hash
memory is thus allocated only once in the game, the table is
reinitialized at the beginning of each move by a call to
@code{hashtable_clear()} from @code{genmove()}.

@menu
* Hash Calculation::            Calculation of the hash value
* Hash Organization::           Organization of the hash table
* Hash Structures::             Structures in @file{hash.h}
* Hash Functions::              Hash functions and macros
@end menu

@node Hash Calculation, Hash Organization, Hashing, Hashing
@comment  node-name,  next,  previous,  up
@subsection Calculation of the hash value

The hash algorithm is called Zobrist hashing, and is a standard
technique for go and chess programming. The algorithm as used by us
works as follows:

@cindex go position
@cindex position

@enumerate
@item First we define a @dfn{go position}.  This positions consists of
@itemize @bullet
@item the actual board, i.e. the locations and colors of the stones
@item A @dfn{ko point}, if a ko is going on.  The ko point is defined as
the empty point where the last single stone was situated before
it was captured.
@end itemize

It is not necessary to specify the color to move (white or black)
as part of the position. The reason for this is that read results
are stored separately for the various reading functions such as
@code{attack3}, and it is implicit in the calling function which
player is to move.

@item For each location on the board we generate random numbers:
@itemize @bullet
@item A number which is used if there is a white stone on this location
@item A number which is used if there is a black stone on this location
@item A number which is used if there is a ko on this location
@end itemize

These random numbers are generated once at initialization time and
then used throughout the life time of the hash table.

@item The hash key for a position is the XOR of all the random numbers
which are applicable for the position (white stones, black stones, and
ko position).
@end enumerate

@node Hash Organization, Hash Structures, Hash Calculation, Hashing
@comment  node-name,  next,  previous,  up
@subsection Organization of the hash table

The hash table consists of 3 parts:

@cindex Hash node
@cindex Read result

@itemize @bullet
@item An area which contains so called @dfn{Hash Nodes}. Each hash node
contains:
@itemize @minus
@item A go position as defined above.
@item A computed hash value for the position
@item A pointer to Read Results (see below)
@item A pointer to another hash node.
@end itemize

@item An area with so called Read Results.  These are used to store
which function was called in the go position, which string was
under attack or to be defended, and the result of the reading.

Each Read Result contains: 
@itemize @minus
@item the function ID (an int between 0 and 255), the position of the
string under attack and a depth value, which is used to
determine how deep the search was when it was made, packed into
one 32 bit integer. 
@item The result of the search (a numeric value) and a position to
play to get the result packed into one 32 bit integer. 
@item A pointer to another Read Result.
@end itemize

@item An array of pointers to hash nodes.  This is the hash table
proper.

@end itemize

When the hash table is created, these 3 areas are allocated using
@code{malloc()}.  When the hash table is populated, all contents are taken
from the Hash nodes and the Read results. No further allocation is
done and when all nodes or results are used, the hash table is full.
Nothing is deleted from the hash table except when it is totally
emptied, at which point it can be used again as if newly initialized.

@findex hashtable_search
When a function wants to use the hash table, it looks up the current
position using @code{hashtable_search()}. If the position doesn't already
exist there, it can be entered using

@findex hashtable_enter_position
@code{hashtable_enter_position()}.  

@findex hashtable_enter_position
Once the function has a pointer to the hash node containing a
function, it can search for a result of a previous search using
@code{hashnode_search()}.  If a result is found, it can be used, and
if not, a new result can be entered after a search using 
@findex hashnode_new_result
@code{hashnode_new_result()}.

Hash nodes which hash to the same position in the hash table
(collisions) form a simple linked list.  Read results for the same
position, created by different functions and different attacked or
defended strings also form a linked list.

This is deemed sufficiently efficient for now, but the representation
of collisions could be changed in the future.  It is also not
determined what the optimum sizes for the hash table, the number of
positions and the number of results are.

@node Hash Structures, Hash Functions, Hash Organization, Hashing
@comment  node-name,  next,  previous,  up
@subsection Hash Structures

The basic hash structures are declared in @file{hash.h}.

@example
typedef struct hashposition_t @{
  Compacttype  board[COMPACT_BOARD_SIZE];
  int          ko_i;
  int          ko_j;
@} Hashposition;
@end example

Represents the board and optionally the location of a ko,
which is an illegal move. The player whose move is next
is not recorded.

@example
typedef struct @{
  Hashvalue     hashval;
  Hashposition  hashpos;
@} Hash_data;
@end example

Represents the return value of a function (@code{hashval}) and
the board state (@code{hashpos}).

@example
typedef struct read_result_t @{
  unsigned int compressed_data;	

  int result_ri_rj;
  struct read_result_t *next;
@} Read_result;
@end example

Here the @code{compressed_data} field packs into 32 bits the
following fields:

@example
 komaster: 2 bits (EMPTY, BLACK, WHITE, or GRAY)
 kom_i   : 5 bits
 kom_j   : 5 bits
 routine : 4 bits (currently 10 different choices)
 i       : 5 bits
 j       : 5 bits
 stackp  : 5 bits
@end example

The @code{komaster} and @code{(kom_i,kom_j)} field are
documented in @xref{Ko}. The integer @code{result_ri_rj} encodes:

@example
  unsigned char  status;
  unsigned char  result;
  unsigned char  ri;
  unsigned char  rj;
@end example

When a new result node is created, 'status' is set to 1 'open'.
This is then set to 2 'closed' when the result is entered. The main
use for this is to identify open result nodes when the hashtable is
partially cleared. Another potential use for this field is to
identify repeated positions in the reading, in particular local
double or triple kos.

@example
typedef struct hashnode_t @{
  Hash_data            key;
  Read_result        * results;
  struct hashnode_t  * next;
@} Hashnode;
@end example

The hash table consists of hash nodes.  Each hash node consists of
The hash value for the position it holds, the position itself and
the actual information which is purpose of the table from the start.

There is also a pointer to another hash node which is used when
the nodes are sorted into hash buckets (see below).

@example
typedef struct hashtable @{
  size_t         hashtablesize;	/* Number of hash buckets */
  Hashnode    ** hashtable;	/* Pointer to array of hashnode lists */

  int            num_nodes;	/* Total number of hash nodes */
  Hashnode     * all_nodes;	/* Pointer to all allocated hash nodes. */
  int            free_node;	/* Index to next free node. */

  int            num_results;	/* Total number of results */
  Read_result  * all_results;	/* Pointer to all allocated results. */
  int            free_result;	/* Index to next free result. */
@} Hashtable;
@end example

The hash table consists of three parts:

@itemize @bullet
@item The hash table proper: a number of hash buckets with collisions
being handled by a linked list.
@item The hash nodes.  These are allocated at creation time and are 
never removed or reallocated in the current implementation.
@item The results of the searches.  Since many different searches can
be done in the same position, there should be more of these than
hash nodes.
@end itemize

@node Hash Functions, Persistent Cache, Hash Structures, Hashing
@comment  node-name,  next,  previous,  up
@subsection Hash Functions

The following functions are defined in @file{hash.c}:

@itemize @bullet
@item @code{void hash_init()}
@quotation
Initialize the entire hash system.
@end quotation
@item @code{int hashdata_compare(Hash_data *key1, Hash_data *key2)}
@findex hashdata_compare
@quotation 
Returns 0 if @code{*key1 == *key2}, 2 if the hashvalues differ, or 1 if 
only the hashpositions differ.
This adheres (almost) to the standard compare function semantics 
which are used e.g. by the comparison functions used in qsort().
@end quotation
@item @code{void hashposition_dump(Hashposition *pos, FILE *outfile)}
@findex hashposition_dump
@quotation
Dump an ASCII representation of the contents of a Hashposition onto
the FILE outfile. 
@end quotation
@item @code{int hashdata_diff_dump(Hash_data *key1,Hash_data *key2 )}
@findex hashdata_diff_dump
@quotation
Compare two Hashdata structs. If equal: return zero. If not: dump a 
human readable summary of any differences to stderr.
The return value is the same as for hashdata_compare. This function is
primarily intended to be used in assert statements.
@end quotation
@item @code{void hashdata_recalc(Hash_data *target, Intersection *p, int kopos)}
@findex hashdata_recalc
@quotation
Calculate the compactboard and the hashvalue in one function.
They are always used together and it saves us a loop and a
function call.
@end quotation
@item @code{void hashdata_set_ko(Hash_data *hd, int pos)}
@findex hashdata_set_ko
@quotation
Set or remove a ko at @code{pos}. 
@end quotation
@item @code{void hashdata_remove_ko(Hash_data *hd)}
@findex hashdata_remove_ko
@quotation
Remove any ko from the hash value and hash position.
@end quotation
@item @code{void hashdata_invert_stone(Hash_data *hd, int pos, int color)}
@findex hashdata_invert_stone
@quotation
Set or remove a stone of @code{color} at @code{pos} in a Hash_data.
@end quotation
@item @code{void read_result_dump(Read_result *result, FILE *outfile)}
@findex read_result_dump
@quotation
Dump an ASCII representation of the contents of a Read_result onto
the FILE outfile.
@end quotation
@item @code{void hashnode_dump(Hashnode *node, FILE *outfile)}
@findex hashnode_dump
@quotation 
Dump an ASCII representation of the contents of a Hashnode onto
the FILE outfile. 
@end quotation
@item @code{int hashtable_init(Hashtable *table, int tablesize, int num_nodes, int num_results)}
@findex hashtable_init
@quotation 
Initialize a hash table for a given total size and size of the
hash table. Returns 0 if something went wrong. Just now this means that there
wasn't enough memory available.
@end quotation
@item @code{Hashtable * hashtable_new(int tablesize, int num_nodes, int num_results)}
@findex hashtable_new
@quotation 
Allocate a new hash table and return a pointer to it. Return NULL if there is
insufficient memory.
@end quotation
@item @code{void hashtable_clear(Hashtable *table)}
@findex hashtable_clear
@quotation
Clear an existing hash table.  
@end quotation
@item @code{void hashtable_clear_if_full(Hashtable *table)}
@findex hashtable_clear_if_full
@quotation
Clear an existing hash table only if it happens to be full. By full
we mean that we are either out of positions or read results.
@end quotation
@item @code{Hashnode * hashtable_enter_position(Hashtable *table, Hash_data *hd)}
@findex hashtable_enter_position
@quotation
Enter a position with a given hash value into the table. Return 
a pointer to the hash node where it was stored.  If it is already
there, don't enter it again, but return a pointer to the old one.
@end quotation
@item @code{Hashnode * hashtable_search(Hashtable *table, Hash_data *hd)}
@findex hashtable_search
@quotation
Given a Hashposition and a Hash value, find the hashnode which contains
this position with the given hash value.
@end quotation
@item @code{void hashtable_dump(Hashtable *table, FILE *outfile)}
@findex hashtable_dump
@quotation
Dump an ASCII representation of the contents of a Hashtable onto
the FILE outfile. 
@end quotation
@end itemize

The following macros are defined in @file{hash.h}

@itemize @bullet
@item @code{rr_get_routine(Read_result rr)}
@item @code{rr_get_pos_i(Read_result rr)}
@item @code{rr_get_pos_j(Read_result rr)}
@item @code{rr_get_stackp(Read_result rr)}
@findex rr_get_routine
@findex rr_get_pos_i
@findex rr_get_pos_j
@findex rr_get_stackp
@quotation
Get the constituent parts of a @code{Read_result}.
@end quotation
@end itemize

The following macros and functions are defined in
@file{engine/reading.c}:

@itemize @bullet
@item @code{static int get_read_result(int routine, int *si, int *sj, Read_result **read_result)}
@findex get_read_result
@quotation
Return a Read_result for the current position, routine and location.
For performance, the location is changed to the origin of the string.
@end quotation
@item @code{READ_RETURN0(Read_result *read_result)}
@findex READ_RETURN0
@quotation
Cache a negative read result.
@end quotation
@item @code{READ_RETURN(Read_result *read_result, int *pointi, int *pointj, int resulti, int resultj, int value)}
@findex READ_RETURN
@quotation
If @code{pointi} and @code{pointj} are not null pointers, then give
@code{(*pointi, *pointj)} the values @code{(resulti, resultj)}. Then
cache the @code{read_result}. Clear the hashtable if full and return
@code{value}.
@end quotation
@end itemize

@node Persistent Cache, Ko, Hash Functions, Tactical Reading
@subsection Persistent Reading Cache

@cindex Persistent reading cache
@findex store_persistent_reading_cache
@findex purge_persistent_reading_cache
@findex search_persistent_reading_cache
@findex store_persistent_reading_cache

Some reading calculations can be safely saved from move to
move. 

The function @code{store_persistent_cache()} is called only
by @code{attack} and @code{find_defense}, never from their
static recursive counterparts @code{do_attack} and @code{do_defend}.
The function @code{store_persistent_reading_cache()} attempts to
cache the most expensive reading results. The function
@code{search_persistent_reading_cache} attempts to retrieve a
result from the cache.

If all cache entries are occupied, we try to replace the least useful
one. This is indicated by the score field, which is initially the
number of nodes expended by this particular reading, and later
multiplied by the number of times it has been retrieved from the
cache.

Once a (permanent) move is made, a number of cache entries immediately become
invalid.  These are cleaned away by the function
@code{purge_persistent_reading_cache().} To have a criterion
for when a result may be purged, the function 
@code{store_persistent_cache()} computes the
@dfn{reading shadow} and @dfn{active area}. If a permanent
move is subsequently played in the active area, the cached
result is invalidated. We now explain this algorithm in detail.

@cindex reading shadow

The @dfn{reading shadow} is the concatenation of all moves in all
variations, as well as locations where an illegal move has been tried.

Once the read is finished, the reading shadow is expanded
to the @dfn{active area} which may be cached. The 
intention is that as long as no stones are played in the
active area, the cached value may safely be used.

Here is the algorithm used to compute the active area.
This algorithm is in the function @code{store_persistent_reading_cache()}.
The most expensive readings so far are stored in the persistent cache.

@itemize @bullet
@item
The reading shadow and the string under attack are marked
with the character @samp{1}. We also include the successful
move, which is most often a part of the reading shadow, but
sometimes not, for example with the function @code{attack1()}.

@item
Next the reading shadow is expanded by marking strings and
empty vertices adjacent to the area marked @samp{1} with
the character @samp{2}.

@item
Next vertices adjacent to empty vertices marked @samp{2} are
labelled with the character @samp{3}.

@item
Next all vertices adjacent to previously marked vertices. These are
marked @samp{-1} instead of the more logical @samp{4} because it
is slightly faster to code this way.

@item
If the stack pointer is >0 we add the moves already played from the
moves stack with mark 4.
@end itemize

@node Ko, A Ko Example, Persistent Cache, Tactical Reading
@section Ko Handling

The principles of ko handling are the same for tactical reading and
owl reading.

We have already mentioned (@pxref{Reading Basics}) that GNU Go
uses a return code of KO_A or KO_B if the result depends on
ko. The return code of KO_B means that the position can be won
provided the player whose move calls the function can come up
with a sufficiently large ko threat. In order to verify this,
the function must simulate making a ko threat and having it
answered by taking the ko even if it is illegal. We call such an
experimental taking of the ko a @dfn{conditional} ko capture.

Conditional ko captures are accomplished by the function @code{tryko()}.
This function is like @code{trymove()} except that
it does not require legality of the move in question.

The static reading functions, and the global functions @code{do_attack}
and @code{do_find_defense} have arguments @code{komaster},
@code{kom_pos}. These mediate ko captures to prevent the
occurrence of infinite loops.

Normally @code{komaster} is @code{EMPTY} but it can also be
@code{BLACK}, @code{WHITE} or @code{GRAY}. The komaster is set to @code{color}
when @code{color} makes a conditional ko capture. In this case
@code{kom_pos} is set to the location of the captured ko
stone.

If the opponent is komaster, the reading functions will not try to
take the ko at @code{kom_pos}. Also, the komaster is normally not
allowed to take another ko. The exception is a nested ko, characterized
by the condition that the captured ko stone is at distance 1 both
vertically and horizontally from @code{kom_pos}, which is the location
of the last stone taken by the komaster. Thus in this situation:

@example

         .OX
         OX*X
        OmOX
         OO

@end example

Here if @samp{m} is the location of @code{kom_pos}, then the move at 
@samp{*} is allowed.

The rationale behind this rule is that in the case where there are
two kos on the board, the komaster cannot win both, and by becoming
komaster he has already chosen which ko he wants to win. But in the
case of a nested ko, taking one ko is a precondition to taking the
other one, so we allow this.

If the komaster's opponent takes a ko, then both players have taken
one ko. In this case `komaster' is set to GRAY and after this further
ko captures are not allowed.

If the ko at @code{kom_pos} is filled, then the komaster
reverts to EMPTY.

The komaster scheme may be summarized as follows. It is assumed
that @samp{O} is about to move.

@itemize @bullet
@item 1. Komaster is EMPTY.
@itemize @minus
@item Unconditional ko capture is allowed. Komaster remains EMPTY.
@item Conditional ko capture is allowed. Komaster is set to @samp{O} and
@code{kom_pos} to the location of the ko, where a stone was
just removed.
@end itemize
@item Komaster is O:
@itemize @minus 
@item Only nested ko captures are allowed.
@item If komaster fill the ko at @code{kom_pos} then komaster reverts to
EMPTY.
@end itemize
@item Komaster is X:
@itemize @minus
@item
Play at @code{kom_pos} is not allowed. Any other ko capture
is allowed. If @samp{O} takes another ko, komaster becomes GRAY.
@end itemize
@item Komaster is GRAY:
@itemize @minus
@item Ko captures are not allowed. If the ko at @code{kom_pos} is
filled then the komaster reverts to EMPTY.
@end itemize
@end itemize

@node A Ko Example, Another Ko Example, Ko, Tactical Reading
@section A Ko Example

To see the komaster scheme in action, consider this position
from the file @file{regressions/games/life_and_death/tripod9.sgf}.
We recommend studying this example by examining the variation file
produced by the command:

@example
  gnugo -l tripod9.sgf --decidedragon C3 -o vars.sgf
@end example

In the lower left hand corner, there are kos at A2 and B4.
Black is unconditionally dead because if W wins either ko 
there is nothing B can do.

@example
@group

 8 . . . . . . . .
 7 . . O . . . . .
 6 . . O . . . . .
 5 O O O . . . . .
 4 O . O O . . . .
 3 X O X O O O O .
 2 . X X X O . . .
 1 X O . . . . . .
   A B C D E F G H

@end group
@end example

This is how the komaster scheme sees this. B (i.e. X) starts by 
taking the ko at B4. W replies by taking the ko at A1. The board 
looks like this:

@example
@group

 8 . . . . . . . .
 7 . . O . . . . .
 6 . . O . . . . .
 5 O O O . . . . .
 4 O X O O . . . .
 3 X . X O O O O .
 2 O X X X O . . .
 1 . O . . . . . .
   A B C D E F G H

@end group
@end example

Now any move except the ko recapture (currently illegal)
at A1 loses for B, so B retakes the ko and becomes komaster.
The board looks like this:

@example
@group

 8 . . . . . . . .         komaster: BLACK
 7 . . O . . . . .         kom_pos: A2
 6 . . O . . . . .
 5 O O O . . . . .
 4 O X O O . . . .
 3 X . X O O O O .
 2 . X X X O . . .
 1 X O . . . . . .
   A B C D E F G H

@end group
@end example

W takes the ko at B3 after which the komaster is GRAY and
ko recaptures are not allowed.

@example
@group

 8 . . . . . . . .         komaster: GRAY
 7 . . O . . . . .         kom_pos: B4
 6 . . O . . . . .
 5 O O O . . . . .
 4 O . O O . . . .
 3 X O X O O O O .
 2 . X X X O . . .
 1 X O . . . . . .
   A B C D E F G H

@end group
@end example

Since X is not allowed any ko recaptures, there is nothing
he can do and he is found dead. Thus the komaster scheme
produces the correct result.


@node Another Ko Example, Alternate Komaster Schemes, A Ko Example, Tactical Reading
@comment  node-name,  next,  previous,  up
@section Another Ko Example

We now consider an example to show why the komaster is reset
to EMPTY if the ko is resolved in the komaster's favor. This
means that the ko is filled, or else that is becomes no longer
a ko and it is illegal for the komaster's opponent to play
there.

The position resulting under consideration is in the file
@file{regressions/games/ko5.sgf}.  This is the position:

@example
@group
 . . . . . . O O 8
 X X X . . . O . 7
 X . X X . . O . 6
 . X . X X X O O 5
 X X . X . X O X 4
 . O X O O O X . 3
 O O X O . O X X 2
 . O . X O X X . 1
 F G H J K L M N
@end group
@end example

We recommend studying this example by
examining the variation file produced by the command:

@example
gnugo -l ko5.sgf --quiet --decidestring L1 -o vars.sgf
@end example

The correct resolution is that H1 attacks L1 while K2
defends it with ko (code KO_A).

After Black (X) takes the ko at K3, white can do nothing
but retake the ko conditionally, becoming komaster. B cannot
do much, but in one variation he plays at K4 and W takes
at H1. The following position results:

@example
@group
 . . . . . . O O 8
 X X X . . . O . 7
 X . X X . . O . 6
 . X . X X X O O 5
 X X . X X X O X 4
 . O X O O O X . 3
 O O X O . O X X 2
 . O O . O X X . 1
 F G H J K L M N
@end group
@end example

Now it is important the @samp{O} is no longer komaster. Were @samp{O}
still komaster, he could capture the ko at N3 and there would be
no way to finish off B.


@node Alternate Komaster Schemes, Superstrings, Another Ko Example,  Tactical Reading
@comment  node-name,  next,  previous,  up
@section Alternate Komaster Schemes

The following alternate schemes have been proposed. It is assumed
that @samp{O} is the player about to move.

@subsection Essentially the 2.7.232 scheme.

@itemize @bullet
@item Komaster is EMPTY.
@itemize @minus
@item Unconditional ko capture is allowed. Komaster remains EMPTY.
@item Conditional ko capture is allowed. Komaster is set to O and
@code{kom_pos} to the location of the ko, where a stone was
just removed.
@end itemize
@item Komaster is O:
@itemize @minus
@item Conditional ko capture is not allowed.
@item Unconditional ko capture is allowed. Komaster parameters unchanged.
@end itemize
@item Komaster is X:
@itemize @minus
@item Conditional ko capture is not allowed.
@item Unconditional ko capture is allowed except for a move at 
@code{kom_pos}. Komaster parameters unchanged.
@end itemize
@end itemize

@subsection Revised 2.7.232 version

@itemize @bullet
@item Komaster is EMPTY.
@itemize @minus
@item Unconditional ko capture is allowed. Komaster remains EMPTY.
@item Conditional ko capture is allowed. Komaster is set to @samp{O} and
@code{kom_pos} to the location of the ko, where a stone was
just removed.
@end itemize
@item Komaster is @samp{O}:
@itemize @minus
@item Ko capture (both kinds) is allowed only if after playing the move,
@code{is_ko(kom_pos, X)} returns false. In that case, 
@code{kom_pos} is updated to the new ko position, i.e. the stone
captured by this move.
@end itemize
@item Komaster is @samp{X}:
@itemize @minus
@item Conditional ko capture is not allowed.
@item Unconditional ko capture is allowed except for a move at 
@code{kom_pos}. Komaster parameters unchanged.
@end itemize
@end itemize

@node Superstrings, Reading Functions, Alternate Komaster Schemes, Tactical Reading
@comment  node-name,  next,  previous,  up
@section Superstrings

A @emph{superstring} is an extended string, where the extensions are
through the following kinds of connections:

@enumerate
@item Solid connections (just like ordinary string).
@example
  OO
@end example
@item Diagonal connection or one space jump through an intersection
where an opponent move would be suicide or self-atari.
@example
@group
  ...
  O.O
  XOX
  X.X
@end group
@end example
@item Bamboo joint.
@example
@group
  OO
  ..
  OO
@end group
@end example
@item Diagonal connection where both adjacent intersections are empty.
@example
@group
  .O
  O.
@end group
@end example
@item Connection through adjacent or diagonal tactically captured stones.
Connections of this type are omitted when the superstring code is
called from @file{reading.c}, but included when the superstring code is
called from @file{owl.c}.
@end enumerate

Like a dragon, a superstring is an amalgamation of strings, but it is
a much tighter organization of stones than a dragon, and its purpose
is different. Superstrings are encountered already in the tactical
reading because sometimes attacking or defending an element of the
superstring is the best way to attack or defend a string. This is
in contrast with dragons, which are ignored during tactical reading.

@node Reading Functions, Debugging, Superstrings, Tactical Reading
@comment  node-name,  next,  previous,  up
@section Reading Functions

Here we list the publically callable functions in @file{reading.c}.
The return codes of these functions are explained elsewhere
(@pxref{Reading Basics}). To briefly repeat this, a reading
function return WIN if the attack succeeds unconditionally, 0 if it doesn't.
It returns KO_A or KO_B if the result depends on ko: 
@itemize @bullet
@item Returns KO_A if the attack succeeds provided attacker is willing to
ignore any ko threat (the attacker makes the first ko capture).
@item Returns KO_B if attack succeeds provided attacker has a ko threat
which must be answered (the defender makes the first ko capture).
@end itemize
@itemize @bullet
@item @code{int attack(int str, int *move)}
@findex attack
@quotation
Determines if the string at (str) can be captured, and if so, (*move) returns
the attacking move, unless (move) is a null pointer. Use a null pointer if you
are interested in the result of the attack but not the attacking move itself.
@end quotation
@item @code{int find_defense(int str, int *move)}
@findex find_defense
@quotation
Attempts to find a move that will save the string at (str). It returns WIN if
such a move is found, with (*move) the location of the saving move, unless
(move) is a null pointer. It is not checked that tenuki defends, so this may
give an erroneous answer if !attack(str).
@end quotation
@item @code{int attack_and_defend(int str, int *attack_code, int *attack_point, int *defend_code, int *defense_point)}
@findex attack_and_defend
@quotation
This is a frontend to the @code{attack()} and @code{find_defense()} functions,
which guarantees a consistent result. If a string cannot be attacked, 0 is
returned and acode is 0. If a string can be attacked and defended, @code{WIN}
is returned, acode and dcode are both non-zero, and (attack_point),
(defense_point) both point to vertices on the board. If a string can be
attacked but not defended, 0 is again returned, acode is non-zero, dcode is 0,
and (attack_point) points to a vertex on the board. This function in
particular guarantees that if there is an attack, it will never return
@code{defense_point}=@code{NO_MOVE}, which means the string is safe without
defense. Separate calls to @code{attack()} and @code{find_defense()} may
occasionally give this result, due to irregularities introduced by the
persistent reading cache.
@end quotation
@item @code{int attack_either(int astr, int bstr)}
@findex attack_either
@quotation
Returns true if there is a move which guarantees that at least one of the
strings (astr) and (bstr) can be captured. A typical application for this is
in connection patterns, where after a cut it suffices to capture one of the
cutting stones. The current implementation only looks for uncoordinated
attacks. This is insufficient to find double ataris or 
moves such as @samp{a} in positions like
@example
       XOOOOOOOX
       XOXXOXXOX
       XX..a..XX
       ---------
@end example
where neither of the threatened X stones can be captured outright.
Still either can be captured by a move down to @samp{a}.
@end quotation
@item @code{int defend_both(int astr, int bstr)}
@findex defend_both
@quotation
Returns true if both the strings @code{astr} and @code{bstr} can be defended
simultaneously or if there is no attack. A typical application for this is in
connection patterns, where after a cut it's necessary to defend both cutting
stones. The current implementation only makes halfhearted attempts to find
coordinated defense moves. A proper implementation would require some serious
reading.
@end quotation
@item @code{int break_through(int apos, int bpos, int cpos)}
@findex break_through
@quotation
returns WIN if a position can succesfully be broken through and CUT if it can
be cut. The position is assumed to have the shape (the colors may be reversed)
@example
.O.       dbe
OXO       aFc
@end example
It is X to move and try to capture at least one of a, b, and c. If
this succeeds, X is said to have broken through the position.
Otherwise X may try to cut through the position, which means
keeping F safe and getting a tactically safe string at either d or
e. @strong{Important}: a, b, and c must be given in the correct order.
@end quotation
@item @code{int attack_threats(int str, int max_points, int moves[], int codes[])}
@findex attack_threats
@quotation
Return up to max_threats threats to capture the string at str. If the string
is directly attackable the number of threats is reported to be 0. NOTE: You
can call attack_threats with moves[] and codes[] already partly filled in. So
if you want to get the threats from scratch, you have to set them to 0
yourself.
@end quotation
@item @code{int safe_move(int move, int color)}
@findex safe_move
@quotation
Checks whether a move at (move) is illegal or can immediately be captured. If
@code{stackp==0} the result is cached. If the move only can be captured by a
ko, it's considered safe.
@end quotation
@item @code{void purge_persistent_reading_cache()}
@findex purge_persistent_reading_cache
@quotation
Remove persistent cache entries which are no longer current.
@end quotation
@item @code{void reading_hotspots(float values[BOARDMAX])}
@findex reading_hotspots
@quotation
Based on the entries in the reading cache and their nodes field,
compute where the relatively most expensive tactical reading is
going on.
@end quotation
@end itemize

@node Debugging, , Reading Functions, Tactical Reading
@comment  node-name,  next,  previous,  up
@section Debugging the reading code

@cindex How to debug the reading code
@cindex Debugging the reading code
@cindex Reading code debugging tools

The reading code searches for a path through the move tree to
determine whether a string can be captured. We have a tool for
investigating this with the @option{--decidestring} option. This may
be run with or without an output file.

Simply running 

@example

@command{gnugo -t -l [input file name] -L [movenumber] --decidestring [location]}

@end example

@noindent
will run @code{attack()} to determine whether the string can be captured.
If it can, it will also run @code{find_defense()} to determine whether or
not it can be defended. It will give a count of the number of
variations read. The @option{-t} is necessary, or else GNU Go will not
report its findings.

If we add @option{-o @var{output file}} GNU Go will produce
an output file with all variations considered. The variations are
numbered in comments.

This file of variations is not very useful without a way of
navigating the source code. This is provided with the GDB
source file, listed at the end. You can source this from GDB,
or just make it your GDB init file.

@cindex GDB

If you are using GDB to debug GNU Go you may find it less
confusing to compile without optimization. The optimization
sometimes changes the order in which program steps are
executed. For example, to compile @file{reading.c} without optimization,
edit @file{engine/Makefile} to remove the string @code{-O2} from
the file, touch @file{engine/reading.c} and make. Note that the
Makefile is automatically generated and may get overwritten
later.

If in the course of reading you need to analyze a result where
a function gets its value by returning a cached position from
the hashing code, rerun the example with the hashing turned off
by the command line option @option{--hash 0}. You should get the same
result. (If you do not, please send us a bug report.) Don't
run @option{--hash 0} unless you have a good reason to, since it 
increases the number of variations. 

With the source file given at the end of this document loaded,
we can now navigate the variations. It is a good idea to use
cgoban with a small @option{-fontHeight}, so that the
variation window takes in a big picture. (You can resize the
board.)

Suppose after perusing this file, we find that variation 17 is
interesting and we would like to find out exactly what is
going on here. 

The macro 'jt n' will jump to the n-th variation.

@example

(gdb) set args -l [filename] -L [move number] --decidestring [location]
(gdb) tbreak main
(gdb) run
(gdb) jt 17

@end example

@noindent
will then jump to the location in question. 

Actually the attack variations and defense variations are numbered
separately. (But @code{find_defense()} is only run if @code{attack()} succeeds,
so the defense variations may or may not exist.) It is redundant to
have to tbreak main each time. So there are two macros avar and dvar.

@example

(gdb) avar 17

@end example

@noindent
restarts the program, and jumps to the 17-th attack variation.

@example

(gdb) dvar 17

@end example

@noindent
jumps to the 17-th defense variation. Both variation sets are
found in the same sgf file, though they are numbered separately.

Other commands defined in this file:

@example

@cindex gnugo's gdb commands 

@command{dump} will print the move stack.
@command{nv} moves to the next variation
@command{ascii i j} converts (i,j) to ascii

#######################################################
###############      .gdbinit file      ###############
#######################################################

# this command displays the stack

define dump
set dump_stack()
end

# display the name of the move in ascii

define ascii
set gprintf("%o%m\n",$arg0,$arg1)
end

# display the all information about a dragon

define dragon
set ascii_report_dragon("$arg0")
end

define worm
set ascii_report_worm("$arg0")
end

# move to the next variation

define nv
tbreak trymove
continue
finish
next
end

# move forward to a particular variation

define jt
while (count_variations < $arg0)
nv
end
nv
dump
end

# restart, jump to a particular attack variation

define avar
delete
tbreak sgffile_decidestring
run
tbreak attack
continue
jt $arg0
end

# restart, jump to a particular defense variation

define dvar
delete
tbreak sgffile_decidestring
run
tbreak attack
continue
finish
next 3
jt $arg0
end

@end example
