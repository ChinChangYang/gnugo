@menu
* Board Data Structures::      Board Data Structures
* Board Setup Functions::      Board Setup Functions
* Move Functions::             Move Functions
* Status Functions::           Status Functions
* String Functions::           String and Miscellaneous Functions
@end menu

The foundation of the GNU Go engine is a library of very efficient
routines for handling go boards.  This board library, called
@file{libboard}, can be used for those programs that only need a
basic go board but no AI capability. One such program is
@code{patterns/joseki} subdirectory, which compiles joseki pattern
databases from SGF files.

The library consists of the following files:

@itemize
@item @file{board.c}
@quotation
The basic board code.  It uses incremental algorithms for keeping track
of strings and liberties on the go board.
@end quotation

@item @file{hash.c}
@quotation
Code for hashing go positions.
@end quotation

@item @file{cache.c}
@quotation
Code for caching go positions
@end quotation

@item @file{globals.c}
@quotation
Global variables needed in the rest of the files.  This file also
contains global variables needed in the rest of the engine.
@end quotation

@item @file{sgffile.c}
@quotation
Implementation of output file in SGF format.
@end quotation

@item @file{showbord.c}
@quotation
Print go boards.
@end quotation

@item @file{printutils.c}
@quotation
Utilities for printing go boards and other things.
@end quotation

@end itemize

To use the board library, you must include @file{liberty.h} just like
when you use the whole engine, but of course you cannot use all the
functions declared in it, i.e. the functions that are part of the
engine, but not part of the board library.  You must link your
application with @code{libboard.a}.

@node Board Data Structures, Board Setup Functions, , Libboard
@section Board Data structures

The basic data structures of the board correspond tightly to the
@code{Position} struct described in @xref{The Position Struct}. They are all
stored in global variables for efficiency reasons, the most important of which
are:

@example
@group

int           board_size;
Intersection  p[MAX_BOARD][MAX_BOARD];
int           board_ko_i;
int           board_ko_j;
int           last_moves_i[2];
int           last_moves_j[2];

float         komi;
int           white_captured;
int           black_captured;

Hash_data     hashdata;
@end group
@end example

The description of the @code{Position} struct is applicable to these
variables also, so we won't duplicate it here.  All these variables are
globals for performance reasons.  Behind these variables, there are a
number of other private data structures.  These implement incremental
handling of strings, liberties and other properties 
(@pxref{Incremental Board}). The variable @code{hashdata} contains information
about the hash value for the current position (@pxref{Hashing}).

These variables should never be manipulated directly, since they are
only the front end for the incremental machinery. They can be read, but
should only be written by using the functions described in the next
section. If you write directly to them, the incremental data structures
will become out of sync with each other, and a crash is the likely
result. 

@node Board Setup Functions, Move Functions, Board Data Structures, Libboard
@section Board Functions

These functions are all the public functions in @file{engine/board.c}.

@subsection Setup Functions

These functions are used when you want to set up a new position without
actually playing out moves.

@itemize @bullet
@item @code{void clear_board()}
@findex clear_board
@quotation
Clears the internal board (@code{p[][]}), resets the ko position,
captured stones and recalculates the hash value.
@end quotation

@item @code{void setup_board(Intersection new_p[MAX_BOARD][MAX_BOARD], int koi, int koj, int *last_i, int *last_j, float new_komi, int w_captured, int b_captured)}
@findex setup_board
@quotation
Set up a new board position using the parameters.
@end quotation

@item @code{void add_stone(int i, int j, int color)}
@findex add_stone
@quotation
Place a stone on the board and update the hashdata.  No captures are
done. 
@end quotation

@item @code{void remove_stone(int i, int j)}
@findex remove_stone
@quotation
Remove a stone from the board and update the hashdata.
@end quotation
@end itemize

@node Move Functions, Status Functions, Board Setup Functions, Libboard
@subsection Move Functions

@strong{Reading}, often called @strong{search} in computer game
theory, is a fundamental process in GNU Go. This is the process
of generating hypothetical future boards in order to determine
the answer to some question, for example "can these stones live."
Since these are hypothetical future positions, it is important
to be able to undo them, ultimately returning to the present
board. Thus a move stack is maintained during reading. When
a move is tried, by the function @code{trymove}, or its
variant @code{tryko}. This function pushes the current board
on the stack and plays a move. The stack pointer @code{stackp},
which keeps track of the position, is incremented. The function
@code{popgo()} pops the move stack, decrementing @code{stackp} and
undoing the last move made.

Every successful @code{trymove()} must be matched with a @code{popgo()}.
Thus the correct way of using this function is:

@example
@group

  if (trymove(i, j, color, [message], k, l, komaster, kom_i, kom_j)) @{
       ...    [potentially lots of code here]
       popgo();
  @}   

@end group
@end example

@noindent
Here the @code{komaster} is only set if a conditional ko capture has been made
at an earlier move. This feature of the tactical and owl reading code in GNU
Go is used to prevent redundant reading when there is a ko on the board
(@pxref{Ko}). If komaster is not defined then take the last three parameters
to be @code{EMPTY}, and @code{-1, -1}.  

@itemize @bullet
@item @code{void play_move(int i, int j, int color)}
@findex play_move
@quotation
Play a move at @code{(i, j)}. If you want to test for legality you
should first call @code{is_legal()}. This function strictly follows the
algorithm:@*
1. Place a stone of given color on the board.@*
2. If there are any adjacent opponent strings without liberties, remove
them and increase the prisoner count.@*
3. If the newly placed stone is part of a string without liberties,
remove it and increase the prisoner count.
@end quotation

@item @code{int trymove(int i, int j, int color, const char *message, int k, int l, int komaster, int kom_i, int kom_j)}
@findex trymove
@quotation
Returns true if @code{(i,j)} is a legal move for @code{color}. In that
case, it pushes the board on the stack and makes the move, incrementing
@code{stackp}. If the reading code is recording reading variations (as
with @option{--decide-string} or with @option{-o}), the string
@code{*message} will be inserted in the SGF file as a comment. The
comment will also refer to the string at @code{(k,l)} if these are not
@code{(-1,-1)}. 
@end quotation
@item @code{int TRY_MOVE()}
@findex TRY_MOVE
@quotation
Wrapper around trymove which suppresses @code{*message} and @code{(k,l)}.
Used in @file{helpers.c}
@end quotation
@item @code{int tryko(int i, int j, int color, const char *message, int komaster, kom_i, kom_j)}
@findex tryko
@quotation
@code{tryko()} pushes the position onto the stack, and makes a move
@code{(i, j)} of @code{color}. The move is allowed even if it is an
illegal ko capture. It is to be imagined that @code{color} has made an
intervening ko threat which was answered and now the continuation is to
be explored. Return 1 if the move is legal with the above
caveat. Returns zero if it is not legal because of suicide.
@end quotation

@item @code{void popgo()}
@findex popgo
@quotation
Pops the move stack. This function must (eventually) be called after a
succesful @code{trymove} or @code{tryko} to restore the board
position. It undoes all the changes done by the call to
@code{trymove/tryko} and leaves the board in the same state as it was
before the call.

@strong{NOTE}: If @code{trymove/tryko} returns @code{0}, i.e. the tried
move was not legal, you must @strong{not} call @code{popgo}.
@end quotation

@item @code{int komaster_trymove(int i, int j, int color,
 const char *message, int si, int sj, 
 int komaster, int kom_i, int kom_j,
 int *new_komaster, int *new_kom_i, int *new_kom_j,
 int *is_conditional_ko, int consider_conditional_ko)}
@findex komaster_trymove
@quotation
Variation of @code{trymove}/@code{tryko} where ko captures (both
conditional and unconditional) must follow a komaster scheme
(@pxref{Ko}).
@end quotation

@item @code{int move_in_stack(int m, int n, int cutoff)}
@findex move_in_stack
@quotation
Returns true if at least one move been played at @code{(m, n)}
at deeper than level 'cutoff' in the reading tree.
@end quotation

@item @code{void get_move_from_stack(int k, int *i, int *j, int *color)}
@findex get_move_from_stack
@quotation
Retrieve the move number @code{k} from the move stack.  The move
location is returned in @code{(*i, *j)}, and the color that made the
move is returned in @code{*color}.
@end quotation

@item @code{void dump_stack(void)}
@findex dump_stack
@quotation
Handy for debugging the reading code under GDB. Prints the move stack.
Usage: @code{(gdb) set dump_stack()}.
@end quotation

@item @code{void reset_trymove_counter()}
@findex reset_trymove_counter
@quotation 
Reset the trymove counter.  This counter is incremented every time that
a variant of @code{trymove} or @code{tryko} is called.
@end quotation

@item @code{int get_trymove_counter()}
@findex get_trymove_counter
@quotation 
Retrieve the trymove counter.
@end quotation
@end itemize

@node Status Functions, String Functions, Move Functions, Libboard
@subsection Status Functions

These functions are used for inquiring about properties of the current
position or of potential moves.

@itemize @bullet
@item @code{int is_pass(int i, int j)}
@findex is_pass
@quotation 
Returns true if the move @code{(i,j)} is a pass move, i.e. @code{(-1,
-1)}.
@end quotation

@item @code{int is_legal(int i, int j, int color)}
@findex is_legal
@quotation 
Returns true if a move at @code{(i,j)} is legal for @code{color}.
@end quotation

@item @code{int is_ko(int m, int n, int color, int *ko_i, int *ko_j)}
@findex is_ko
@quotation
Return true if the move @code{(i,j)} by @code{color} is a ko capture
whether capture is a legal ko capture on this move or not. If
@code{(*ko_i,*ko_j)} are non-@code{NULL}, then the location of the
captured ko stone are returned through @code{(*ko_i,*ko_j)}. If the move
is not a ko capture, @code{(*ko_i,*ko_j)} is set to @code{(-1, -1)}.
@end quotation

@item @code{int is_illegal_ko_capture(int i, int j, int color)}
@findex is_illegal_ko_capture
@quotation
Return true if the move @code{(i,j)} by @code{color} would be an illegal
ko capture.  There is no need to call both @code{is_ko} and
@code{is_illegal_ko_capture}. 
@end quotation

@item @code{int is_self_atari(int i, int j, int color)}
@findex is_self_atari
@quotation
Return true if a move by @code{color} at @code{(i, j)} would be a self
atari, i.e. whether it would get only one liberty. This function returns
true also for the case of a suicide move.
@end quotation

@item @code{int is_suicide(int i, int j, int color)}
@findex is_suicide
@quotation 
Returns true if a move at @code{(i,j)} is suicide for @code{color}.
@end quotation

@item @code{int does_capture_something(int i, int j, int color)}
@findex does_capture_something
@quotation 
Returns true if a move at @code{(i,j)} does capture any stone for the
other side.
@end quotation

@item @code{int stones_on_board(int color)}
@findex stones_on_board
@quotation
Return the number of stones of the indicated color(s) on the board. This
only count stones in the permanent position, not stones placed by
@code{trymove()} or @code{tryko()}. Use
@code{stones_on_board(BLACK | WHITE)} to get the total number of stones
on the board.
@end quotation
@end itemize

@node String Functions, , Status Functions, Libboard
@subsection String and Miscellaneous Functions

These functions are used for getting information like liberties, member
stones and similar about strings. Most of these are here because they
have a particularly efficient implementation through access to the
incremental data structures behind the scene.

@itemize @bullet

@item @code{void find_origin(int i, int j, int *origini, int *originj)}
@findex find_origin
@quotation
Find the origin of a worm or a cavity, i.e. the point with smallest
@samp{i} coordinate and in the case of a tie with smallest @samp{j} coordinate.
The idea is to have a canonical reference point for a string.
@end quotation

@item @code{int findstones(int m, int n, int maxstones, int *stonei, int *stonej)}
@findex findstones
@quotation
Find the stones of the string at @code{(m, n)}. @code{(m, n)} must not
be empty. The locations of up to @code{maxstones} stones are written into
@code{(stonei[], stonej[])}. The full number of stones is returned.
@end quotation

@item @code{int countstones(int m, int n)}
@findex countstones
@quotation
Count the number of stones in a string.
@end quotation

@item @code{void mark_string(int i, int j, char mx[MAX_BOARD][MAX_BOARD], char mark)}
@findex mark_string
@quotation
For each stone in the string at @code{(i, j)}, set @code{mx} to value 
@code{mark}. If some of the stones in the string are marked prior to calling
this function, only the connected unmarked stones starting from @code{(i, j)}
are guaranteed to become marked. The rest of the string may or may not become
marked.
@end quotation

@item @code{int liberty_of_string(int ai, int aj, int si, int sj)}
@findex liberty_of_string
@quotation
Returns true if @code{(ai, aj)} is a liberty of the string at @code{(si, sj)}.
@end quotation

@item @code{int neighbor_of_string(int ai, int aj, int si, int sj)}
@findex neighbor_of_string
@quotation
Returns true if @code{(ai, aj)} is adjacent to the string at @code{(si, sj)}.
@end quotation

@item @code{int same_string(int ai, int aj, int bi, int bj)}
@findex same_string
@quotation
Returns true if @code{(ai, aj)} is a stone in the same string as
@code{(bi, bj)}.
@end quotation

@item @code{int findlib(int m, int n, int maxlib, int *libi, int *libj)}
@findex findlib
@quotation
Find the liberties of the string at @code{(m, n)}, which must not be
empty. The locations of up to maxlib liberties are written into
@code{(libi[], libj[])}. The full number of liberties is returned.
If you want the locations of all liberties, whatever their number,
you should pass @code{MAXLIBS} as the value for maxlib and allocate space
for @code{libi[], libj[]} accordingly.
@end quotation

@item @code{int countlib(int m, int n)}
@findex countlib
@quotation
Count the number of liberties of the string at @code{(m,n)}, which
must not be empty.
@end quotation

@item @code{int approxlib(int m, int n, int maxlib, int *libi, int *libj)}
@findex approxlib
@quotation
Find the liberties a stone of the given color would get if played at @code{(m,
n)}, ignoring possible captures of opponent stones.  @code{(m, n)} must be
empty. If @code{libi!=NULL}, the locations of up to maxlib liberties are
written into @code{(libi[], libj[])}. The counting of liberties may or may not
be halted when maxlib is reached. The number of liberties found is
returned. If you want the number or the locations of all liberties, however
many they are, you should pass @code{MAXLIBS} as the value for maxlib and
allocate space for @code{libi[], libj[]} accordingly.
@end quotation

@item @code{int chainlinks(int m, int n, int adji[MAXCHAIN], int adjj[MAXCHAIN])}:
@findex chainlinks
@quotation
Returns (in @code{adji[]}, @code{adjj[]} arrays) the chain (strings)
surrounding the string at @code{(m, n)}.  The chain is defined as the
set of strings in immediate connection to the @code{(m, n)} string.
Return value is the number of strings in the chain.
@end quotation

@item @code{void chainlinks2(int m, int n, int adji[MAXCHAIN], int adjj[MAXCHAIN], int lib)}
@findex chainlinks2
@quotation
Returns (in @code{adji[]}, @code{adjj[]} arrays) the strings surrounding
the string at @code{(m, n)}, which have exactly @code{lib} liberties.
@end quotation
@end itemize


@subsection Miscellaneous Functions

@itemize @bullet
@item @code{void incremental_order_moves(int mi, int mj, int color, 
                            int si, int sj, 
                            int *number_edges, int *number_same_string,
                            int *number_own, int *number_opponent, 
                            int *captured_stones, int *threatened_stones,
                            int *saved_stones, int *number_open)}
@findex incremental_order_moves
@quotation
Help collect the data needed by @code{order_moves()} in @file{reading.c}.
It's the caller's responsibility to initialize the result parameters.
@end quotation
@end itemize

@section Hashing of Board Positions

Hashing of go positions in a hash table (sometimes also called a
transposition table) is implemented in @code{libboard}, in @file{hash.c}
and @code{cache.c} to be exact.  

To use the hash function, you must include @file{hash.h} and to use the
entire hash table, you must include @file{cache.h} in your program.  The
details are described in @ref{Hashing}.








