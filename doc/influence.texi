@menu
* Influential Concepts::        Conceptual Outline of Influence
* The Influence Core::          The Core of the Influence Function
* The Influence Algorithm::     The algorithm of @code{accumlate_influence()}
* Permeability::                Permeability
* Escape::                      Escape
* Influential Functions::       Functions in @file{engine/influence.c}
* Influential Display::         Colored display and debugging of influence
@end menu

@node Influential Concepts, The Influence Core, Influence, Influence
@comment  node-name,  next,  previous,  up
@section Conceptual Outline of Influence
@cindex moyo
@cindex territory
@cindex area

We define @dfn{lively} stones to be all stones that can't be tactically
attacked or have a tactical defense. Stones that have been found to be
strategically dead are called dead while all other stones are called
@dfn{alive}. If we want to use the influence function before deciding the
strategical status, all lively stones count as alive.

Every alive stone on the board works as an influence source, with
influence of its color radiating outwards in all directions. The
strength of the influence declines exponentially with the distance
from the source.

Influence can only flow unhindered if the board is empty, however. All
lively stones (regardless of color) act as influence barriers, as do
connections between enemy stones that can't be broken through. For
example the one space jump counts as a barrier unless either of the
stones can be captured. Notice that it doesn't matter much if the
connection between the two stones can be broken, since in that case
there would come influence from both directions anyway.

We define @dfn{territory} to be the intersections where one color has no
influence at all and the other player does have. We can introduce moyo
and area concepts similar to those provided by the Bouzy algorithms in
terms of the influence values for the two colors. ``Territory'' refers
to certain or probable territory while ``Moyo'' refers to an area of
dominant influence which is not necessarily guaranteed territory.
``Area'' refers to the breathing space around a group in which it
can manoever if it is attacked.

In order to avoid finding bogus territory, we add extra influence
sources at places where an invasion can be launched, e.g. at 3-3 under
a handicap stone, in the middle of wide edge extensions and in the
center of large open spaces anywhere. Similarly we add extra influence
sources where intrusions can be made into what otherwise looks as
solid territory, e.g. monkey jumps.

Walls typically radiate an influence that is stronger than the sum of
the influence from the stones building the wall. To accommodate for this
phenomenon, we also add extra influence sources in empty space at
certain distances away from walls.


@node The Influence Core, The Influence Algorithm, Influential Concepts, Influence
@comment  node-name,  next,  previous,  up
@section The Core of the Influence Function

The basic influence radiation process can efficiently be implemented
as a breadth first search for adjacent and more distant points, using
a queue structure.

Influence barriers can be found by pattern matching, assisted by
reading through constraints and/or helpers. Wall structures, invasion
points and intrusion points can be found by pattern matching as well.

When influence is computed, the basic idea is that there are a number
of influence sources on the board, whose contributions are summed to
produce the influence values. For the time being we can assume that
the living stones on the board are the influence sources, although
this is not the whole story.

The function @code{compute_influence()} contains a loop over the
board, and for each influence source on the board, the function
@code{accumulate_influence()} is called. This is the core of the
influence function. Before we get into the details, this is how
the influence field from a single isolated influence source of
strength 100 turns out:

@example
  0  0  0  0  0  0  0  0  0  0  0
  0  0  0  0  1  1  1  0  0  0  0
  0  0  0  1  2  3  2  1  0  0  0
  0  0  1  3  5 11  5  3  1  0  0
  0  1  2  5 16 33 16  5  2  1  0
  0  1  3 11 33  X 33 11  3  1  0
  0  1  2  5 16 33 16  5  2  1  0
  0  0  1  3  5 11  5  3  1  0  0
  0  0  0  1  2  3  2  1  0  0  0
  0  0  0  0  1  1  1  0  0  0  0
  0  0  0  0  0  0  0  0  0  0  0
@end example

These values are in reality floating point numbers but have been
rounded down to the nearest integer for presentation. This means that
the influence field does not stop when the numbers become zeroes.

Internally @code{accumulate_influence()} starts at the influence source and
spreads influence outwards by means of a breadth first propagation,
implemented in the form of a queue. The order of propagation and the
condition that influence only is spread outwards guarantee that no
intersection is visited more than once and that the process
terminates. In the example above, the intersections are visited in the
following order:

@example
  +  +  +  +  +  +  +  +  +  +  +
  + 78 68 66 64 63 65 67 69 79  +
  + 62 46 38 36 35 37 39 47 75  +
  + 60 34 22 16 15 17 23 43 73  +
  + 58 32 14  6  3  7 19 41 71  +
  + 56 30 12  2  0  4 18 40 70  +
  + 57 31 13  5  1  8 20 42 72  +
  + 59 33 21 10  9 11 24 44 74  +
  + 61 45 28 26 25 27 29 48 76  +
  + 77 54 52 50 49 51 53 55 80  +
  +  +  +  +  +  +  +  +  +  +  +
@end example

The visitation of intersections continues in the same way on the
intersections marked '@samp{+} and further outwards. In a real
position there will be stones and tight connections stopping the
influence from spreading to certain intersections. This will
disrupt the diagram above, but the main property of the
propagation still remains, i.e. no intersection is visited more
than once and after being visited no more influence will be
propagated to the intersection.

@node The Influence Algorithm, Permeability, The Influence Core, Influence
@comment  node-name,  next,  previous,  up
@section The Core of the Influence Function

Let @code{(m, n)} be the coordinates of the influence source and
@code{(i, j)} the coordinates of a an intersection being visited
during propagation, using the same notation as in the
@code{accumulate_influence()} function.  Influence is now propagated to
its eight closest neighbors, including the diagonal ones,
according to the follow scheme:

For each of the eight directions @code{(di, dj)}, do:

@enumerate 
@item 
Compute the scalar product @code{di*(i-m) + dj*(j-n)}
between the vectors @code{(di,dj)} and @code{(i,j) - (m,n)}
@item If this is negative or zero, the direction is not outwards and
we continue with the next direction. The exception is when we
are visiting the influence source, i.e. the first intersection,
when we spread influence in all directions anyway.
@item If @code{(i+di, j+dj)} is outside the board or occupied we
also continue with the next direction.
@item Let S be the strength of the influence at @code{(i, j)}. The influence
propagated to @code{(i+di, j+dj)} from this intersection is given by
@code{P*(1/A)*D*S}, where the three different kinds of damping are:

@itemize @bullet
@item The permeability @samp{P}, which is a property of the board
intersections. Normally this is one, i.e. unrestricted
propagation, but to stop propagation through e.g. one step
jumps, the permeability is set to zero at such intersections
through pattern matching. This is further discussed below.
@item The attenuation @samp{A}, which is a property of the influence
source and different in different directions. By default this has the
value 3 except diagonally where the number is twice as much. By
modifying the attenuation value it is possible to obtain influence
sources with a larger or a smaller effective range.
@item The directional damping @samp{D}, which is the squared cosine of the
angle between @code{(di,dj)} and @code{(i,j) - (m,n)}. The idea is to
stop influence from "bending" around an interfering stone and
get a continuous behavior at the right angle cutoff. The
choice of the squared cosine for this purpose is rather
arbitrary, but has the advantage that it can be expressed as a
rational function of @samp{m}, @samp{n}, @samp{i}, @samp{j},
@samp{di}, and @samp{dj}, without involving any trigonometric or
square root computations. When we are visiting the influence
source we let by convention this factor be one.
@end itemize
@end enumerate

Influence is typically contributed from up to three neighbors
"between" this intersection and the influence source. These values are
simply added together. As pointed out before, all contributions will
automatically have been made before the intersection itself is
visited.

When the total influence for the whole board is computed by
@code{compute_influence()}, @code{accumulate_influence()} is
called once for each influence source. These invocations are
totally independent and the influence contributions from the
different sources are added together.

@node Permeability, Escape, The Influence Algorithm, Influence
@comment  node-name,  next,  previous,  up
@section Permeability

The permeability at the different points is initially one at all empty
intersections and zero at occupied intersections. To get a useful
influence function we need to modify this, however. Consider the
following position:

@example
|......
|OOOO..
|...O..
|...a.X   ('a' empty intersection)
|...O..
|...OOO
|.....O
+------
@end example

The corner is of course secure territory for @samp{O} and clearly
the @samp{X} stone has negligible effect inside this position. To
stop @samp{X} influence from leaking into the corner we use pattern
matching (pattern Barrier1/Barrier2 in @file{barriers.db}) to modify the
permeability for @samp{X} at this intersection to zero. @samp{O} can still
spread influence through this connection.

Another case that needs to be mentioned is how the permeability
damping is computed for diagonal influence radiation. For horizontal
and vertical radiation we just use the permeability (for the relevant
color) at the intersection we are radiating from. In the diagonal case
we additionally multiply with the maximum permeability at the two
intersections we are trying to squeeze between. The reason for this
can be found in the diagram below:

@example
|...X    |...X    
|OO..    |Oda.
|..O.    |.bc.
|..O.    |..O.
+----    +----
@end example

We don't want @samp{X} influence to be spread from @samp{a} to
@samp{b}, and since the permeability at both c and d is zero, the
rule above stops this.

@node Escape, Influential Functions, Permeability, Influence
@comment  node-name,  next,  previous,  up
@section Escape

One application of the influence code is in computing the
@code{dragon.escape_route} field. This is computed by the function
@code{compute_escape()} as follows.  First, every intersection is
assigned an escape value, ranging between 0 and 4, depending on
the influence value of the opposite color. 

In addition to assiging an escape value to empty vertices,
we also assign an escape value to friendly dragons. This
value can range from 0 to 6 depending on the status of 
the dragon, with live dragons having value 6.

Then we sum the values of the resulting influence escape values
over the intersections (including friendly dragons) at distance 4,
that is, over those intersections which can be joined to the
dragon by a path of length 4 (and no shorter path) not passing
adjacent to any unfriendly dragon. In the following example, we
sum the influence escape value over the four vertices labelled
'4'.

@example
   
   . . . . . . . . .    . . . . . . . . .
   . . . . . X . . O    . . . . . X . . O
   . . X . . . . . O    . . X . 2 . 4 . O
   X . . . . . . . .    X . . 1 1 2 3 4 .
   X O . O . . . . O    X O 1 O 1 2 3 4 O
   X O . O . . . . .    X O 1 O 1 . 4 . .
   X O . . . X . O O    X O 1 . . X . . O
   . . . X . . . . .    . 1 . X . . . . .
   X . . . . X . . .    X . . . . X . . .
   . . . . . . . . .    . . . . . . . . .

@end example

Since the dragon is trying to reach safety, the reader might
wonder why @code{compute_influence()} is called with the opposite
color of the dragon contemplating escape.  To explain this point,
we first remind the reader why there is a color parameter to
@code{compute_influence()}. Consider the following example position:
@example

     ...XX...
     OOO..OOO
     O......O
     O......O
     --------

@end example

Whether the bottom will become O territory depends on who is in turn
to play. This is implemented with the help of patterns in barriers.db,
so that X influence is allowed to leak into the bottom if X is in turn
to move but not if O is. There are also ``invade'' patterns which add
influence sources in sufficiently open parts of the board which are
handled differently depending on who is in turn to move.

In order to decide the territorial value of an O move in the third
line gap above, influence is first computed in the original position
with the opponent (i.e. X) in turn to move. Then the O stone is played
to give:

@example

     ...XX...
     OOO.OOOO
     O......O
     O......O
     --------

@end example

Now influence is computed once more, also this time with X in turn to
move. The difference in territory (as computed from the influence
values) gives the territorial value of the move.

Exactly how influence is computed for use in the escape route
estimation is all ad hoc. But it makes sense to assume the opponent
color in turn to move so that the escape possibilities aren't
overestimated. After we have made a move in the escape direction
it is after all the opponent's turn.

The current escape route mechanism seems good enough to be useful
but is not completely reliable. Mostly it seems to err on the side of
being too optimistic.

@node Influential Functions, Influential Display, Escape, Influence
@comment  node-name,  next,  previous,  up
@section Influential Functions

@itemize @bullet 
@item @code{static void accumulate_influence(struct influence_data *q, int m, int n, int color)}
@findex accumulate_influence
@quotation
Limited in scope to @file{influence.c}, this is the core of the influence
function. Given the coordinates and color of an influence source, it radiates
the influence outwards until it hits a barrier or the strength of the
influence falls under a certain threshold. The radiation is performed by a
breadth first propagation, implemented by means of an internal queue.
@end quotation
@item @code{void compute_initial_influence(int color, int dragons_known)}
@findex compute_initial_influence
@quotation
Compute the influence before a move has been made, which can
later be compared to the influence after a move. Assume that
the other color is in turn to move.
@end quotation
@item @code{static void compute_move_influence(int m, int n, int color)}
@findex compute_move_influence
@quotation
Let color play at (m, n) and compute the influence after this move,
assuming that the other color is in turn to move next.
@end quotation
@item @code{int influence_territory_color(int m, int n)}
@findex influence_territory_color
@quotation
Return the color who has territory at (m, n), or EMPTY.
@end quotation
@item @code{int influence_moyo_color(int m, int n)}
@findex influence_moyo_color
@quotation
Return the color who has moyo at (m, n), or EMPTY.
@end quotation
@item @code{int influence_area_color(int m, int n)}
@findex influence_area_color
@quotation
Return the color who has area at (m, n), or EMPTY.
@end quotation
@item @code{int influence_delta_territory(int m, int n, int color)}
@findex influence_delta_territory
@quotation
Compute the difference in territory made by a move by color at (m, n).
@end quotation
@item @code{int influence_delta_moyo(int m, int n, int color)}
@findex influence_delta_moyo
@quotation
Compute the difference in moyo made by a move by color at (m, n).
@end quotation
@item @code{int influence_delta_strict_moyo(int m, int n, int color)}
@findex influence_delta_strict_moyo
@quotation
Compute the difference in strict moyo made by a move by color at (m, n).
@end quotation
@item @code{int influence_delta_area(int m, int n, int color)}
@findex influence_delta_area
@quotation
Compute the difference in area made by a move by color at (m, n).
@end quotation
@item @code{int influence_delta_strict_area(int m, int n, int color)}
@findex influence_delta_strict_area
@quotation
Compute the difference in strict area made by a move by color at (m, n).
@end quotation
@item @code{void debug_influence_move(int i, int j)}
@findex debug_influence_move
@quotation
Print the influence map when we have computed influence for the
move at (i, j).
@end quotation
@end itemize

@node Influential Display, ,Influential Functions, Influence
@comment  node-name,  next,  previous,  up
@section Colored display and debugging of influence

It is possible to obtain colored diagrams showing influence from
a colored xterm or rxvt window.

@itemize @bullet
@item @option{-m 0x08} or @option{-m 8}
@quotation
Show diagrams for the initial influence computation. This is done
twice, the first time before @code{make_dragons()} is run and the second time
after. The difference is that dead dragons are taken into account the
second time. Tactically captured worms are taken into account both
times. 
@end quotation
@item @option{-m 0x010} or @option{-m 16}.
@quotation
Show colored display of territory/moyo/area regions.
@itemize @minus
@item territory: cyan
@item moyo: yellow
@item area: red
@end itemize
Use either with @option{-m 0x8} (i.e. use @option{-m 0x18}) or
with @option{--debuginfluence}.
@end quotation
@item @option{-m 0x20} or @option{-m 32}.
@quotation
Show numerical influence values for white and black. These come in
two separate diagrams, the first one for white, the second one for
black. Notice that the influence values are represented by floats and
thus have been rounded in these diagrams.
Use either with @option{-m 0x8} (i.e. use @option{-m 0x28}) or
with @option{--debuginfluence}.
@end quotation
@item @option{--debuginfluence @var{location}}
@quotation
Show influence diagrams after the move at the given location. An
important limitation of this option is that it's only effective for
moves that the move generation is considering.
@end quotation
@item @option{-d 0x20}
@quotation
Turn on @code{DEBUG_INFLUENCE}. This gives tons of messages from the pattern
matching performed by the influence code. Too many to be really
useful, unfortunately.
@end quotation
@end itemize

Notice that you need to activate at least one of @option{-m 0x8} or
@option{--debuginfluence}, and at least one of @option{-m 0x10} and
@option{-m 0x20}, to get any diagrams at all. The first two determine when to
print diagrams while the last two determine what diagrams to print.


